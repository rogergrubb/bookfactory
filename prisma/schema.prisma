// BookFactory AI - Prisma Schema
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id                    String    @id @default(cuid())
  clerkId               String    @unique
  email                 String    @unique
  name                  String?
  avatar                String?
  bio                   String?
  website               String?
  twitter               String?
  
  plan                  Plan      @default(FREE)
  stripeCustomerId      String?   @unique
  stripeSubscriptionId  String?   @unique
  subscriptionStatus    String?
  aiCreditsUsed         Int       @default(0)
  
  theme                 String    @default("system")
  autoSave              Boolean   @default(true)
  autoSaveInterval      Int       @default(30)
  wordCountGoal         Int       @default(1000)
  
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  lastActiveAt          DateTime  @default(now())
  
  books                 Book[]
  series                Series[]
  collaborations        Collaborator[]
  aiUsage               AIUsage[]
  royalties             Royalty[]
  expenses              Expense[]
  campaigns             Campaign[]
  
  writingSessions       WritingSession[]
  activities            Activity[]
  toolRuns              ToolRun[]
  
  @@map("users")
}

enum Plan {
  FREE
  CREATOR
  PROFESSIONAL
  ENTERPRISE
}

model Book {
  id              String      @id @default(cuid())
  userId          String
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  title           String
  subtitle        String?
  description     String?
  genre           String
  template        String?
  coverUrl        String?
  
  status          BookStatus  @default(DRAFT)
  wordCount       Int         @default(0)
  targetWordCount Int         @default(80000)
  targetChapters  Int         @default(20)
  
  seriesId        String?
  series          Series?     @relation(fields: [seriesId], references: [id])
  seriesOrder     Int?
  
  isbn            String?
  asin            String?
  publishedAt     DateTime?
  price           Float?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // AI-generated content storage
  metadata        Json?
  
  chapters        Chapter[]
  characters      Character[]
  collaborators   Collaborator[]
  sales           Sale[]
  versions        BookVersion[]
  feedback        Feedback[]
  campaigns       Campaign[]
  
  @@index([userId])
  @@index([seriesId])
  @@map("books")
}

enum BookStatus {
  DRAFT
  WRITING
  EDITING
  PUBLISHED
  ARCHIVED
}

model Chapter {
  id          String        @id @default(cuid())
  bookId      String
  book        Book          @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  title       String
  content     String        @db.Text
  wordCount   Int           @default(0)
  order       Int
  status      ChapterStatus @default(DRAFT)
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  scenes      Scene[]
  feedback    Feedback[]
  
  @@index([bookId])
  @@map("chapters")
}

enum ChapterStatus {
  DRAFT
  COMPLETE
  REVISION
}

model Scene {
  id          String    @id @default(cuid())
  chapterId   String
  chapter     Chapter   @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  
  title       String?
  content     String    @db.Text
  wordCount   Int       @default(0)
  order       Int
  pov         String?
  location    String?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([chapterId])
  @@map("scenes")
}

model Series {
  id          String       @id @default(cuid())
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name        String
  description String?
  genre       String
  status      SeriesStatus @default(ONGOING)
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  
  books       Book[]
  characters  SeriesCharacter[]
  settings    SeriesSetting[]
  timeline    TimelineEvent[]
  
  @@index([userId])
  @@map("series")
}

enum SeriesStatus {
  ONGOING
  COMPLETED
  HIATUS
}

model Character {
  id          String    @id @default(cuid())
  bookId      String
  book        Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  name        String
  role        String
  description String?
  traits      String[]
  backstory   String?   @db.Text
  imageUrl    String?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([bookId])
  @@map("characters")
}

model SeriesCharacter {
  id          String    @id @default(cuid())
  seriesId    String
  series      Series    @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  
  name        String
  role        String
  description String?
  traits      String[]
  appearsIn   String[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([seriesId])
  @@map("series_characters")
}

model SeriesSetting {
  id          String    @id @default(cuid())
  seriesId    String
  series      Series    @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  
  name        String
  type        String
  description String?
  usedIn      String[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([seriesId])
  @@map("series_settings")
}

model TimelineEvent {
  id          String    @id @default(cuid())
  seriesId    String
  series      Series    @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  
  title       String
  date        String
  description String?
  type        String
  bookId      String?
  
  createdAt   DateTime  @default(now())
  
  @@index([seriesId])
  @@map("timeline_events")
}

model Collaborator {
  id          String            @id @default(cuid())
  bookId      String
  book        Book              @relation(fields: [bookId], references: [id], onDelete: Cascade)
  userId      String?
  user        User?             @relation(fields: [userId], references: [id])
  
  email       String
  role        CollaboratorRole
  status      CollaboratorStatus @default(PENDING)
  permissions String[]
  
  invitedAt   DateTime          @default(now())
  acceptedAt  DateTime?
  
  feedback    Feedback[]
  
  @@unique([bookId, email])
  @@index([bookId])
  @@map("collaborators")
}

enum CollaboratorRole {
  BETA_READER
  EDITOR
  CO_AUTHOR
}

enum CollaboratorStatus {
  PENDING
  ACTIVE
  COMPLETED
  DECLINED
}

model Feedback {
  id              String        @id @default(cuid())
  bookId          String
  book            Book          @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chapterId       String?
  chapter         Chapter?      @relation(fields: [chapterId], references: [id])
  collaboratorId  String
  collaborator    Collaborator  @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)
  
  type            FeedbackType
  content         String        @db.Text
  selection       String?
  status          FeedbackStatus @default(NEW)
  
  createdAt       DateTime      @default(now())
  resolvedAt      DateTime?
  
  @@index([bookId])
  @@index([chapterId])
  @@map("feedback")
}

enum FeedbackType {
  COMMENT
  SUGGESTION
  ISSUE
}

enum FeedbackStatus {
  NEW
  REVIEWED
  RESOLVED
  REJECTED
}

model BookVersion {
  id          String    @id @default(cuid())
  bookId      String
  book        Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  version     Int
  changes     String
  wordCount   Int
  snapshot    Json
  
  createdAt   DateTime  @default(now())
  createdBy   String
  
  @@index([bookId])
  @@map("book_versions")
}

model Sale {
  id          String    @id @default(cuid())
  bookId      String
  book        Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  date        DateTime
  platform    String
  quantity    Int
  revenue     Float
  royalty     Float
  currency    String    @default("USD")
  country     String?
  
  createdAt   DateTime  @default(now())
  
  @@index([bookId])
  @@index([date])
  @@map("sales")
}

model Royalty {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  platform    String
  period      String
  amount      Float
  currency    String    @default("USD")
  status      PaymentStatus @default(PENDING)
  date        DateTime
  
  createdAt   DateTime  @default(now())
  paidAt      DateTime?
  
  @@index([userId])
  @@map("royalties")
}

enum PaymentStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
}

model Expense {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  category    String
  description String
  amount      Float
  currency    String    @default("USD")
  date        DateTime
  bookId      String?
  receipt     String?
  
  createdAt   DateTime  @default(now())
  
  @@index([userId])
  @@map("expenses")
}

model Campaign {
  id          String          @id @default(cuid())
  userId      String
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookId      String?
  book        Book?           @relation(fields: [bookId], references: [id])
  
  name        String
  type        CampaignType
  content     String          @db.Text
  platforms   String[]
  status      CampaignStatus  @default(DRAFT)
  
  scheduledAt DateTime?
  publishedAt DateTime?
  
  reach       Int             @default(0)
  clicks      Int             @default(0)
  conversions Int             @default(0)
  
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  
  @@index([userId])
  @@map("campaigns")
}

enum CampaignType {
  EMAIL
  SOCIAL
  ADS
}

enum CampaignStatus {
  DRAFT
  SCHEDULED
  ACTIVE
  COMPLETED
  PAUSED
}

model AIUsage {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type        String
  inputTokens Int
  outputTokens Int
  bookId      String?
  
  createdAt   DateTime  @default(now())
  
  @@index([userId])
  @@index([createdAt])
  @@map("ai_usage")
}

// ============================================
// WRITING SESSIONS & ACTIVITY
// ============================================

model WritingSession {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  date        DateTime  @db.Date
  wordsWritten Int      @default(0)
  duration    Int       @default(0)  // in seconds
  bookId      String?
  chapterId   String?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@map("writing_sessions")
}

model Activity {
  id          String       @id @default(cuid())
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type        ActivityType
  message     String
  metadata    Json?
  bookId      String?
  chapterId   String?
  
  createdAt   DateTime     @default(now())
  
  @@index([userId])
  @@index([createdAt])
  @@map("activities")
}

enum ActivityType {
  BOOK_CREATED
  BOOK_UPDATED
  BOOK_PUBLISHED
  CHAPTER_CREATED
  CHAPTER_COMPLETED
  WORDS_WRITTEN
  STREAK_ACHIEVED
  AI_USED
  EXPORT_COMPLETED
  COLLABORATOR_INVITED
  FEEDBACK_RECEIVED
}

// ============================================
// AI STUDIO - TOOL RUNS & WORKFLOWS
// ============================================

model ToolRun {
  id                  String    @id @default(cuid())
  userId              String
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  bookId              String
  documentId          String?   // Scene ID for scene-scope tools
  toolId              String
  scope               String    // 'scene' | 'book' | 'hybrid'
  scopeSelection      Json?     // For hybrid tools: { mode, sceneId?, chapterIds?, bookId }
  
  input               String    @db.Text
  output              String?   @db.Text
  context             Json?     // Additional context passed to the tool
  options             Json?     // Tool options (length, tone, customInstructions)
  result              Json?     // Structured result for analysis tools
  
  tokensUsed          Int       @default(0)
  processingTime      Int       @default(0)  // in ms
  status              String    @default("pending")  // 'pending' | 'running' | 'completed' | 'failed'
  error               String?
  
  workflowId          String?
  workflow            Workflow? @relation(fields: [workflowId], references: [id])
  previousToolRunId   String?
  savedToDocumentId   String?   // Scene ID if saved
  appliedAt           DateTime?
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  
  @@index([userId])
  @@index([bookId])
  @@index([workflowId])
  @@map("tool_runs")
}

model Workflow {
  id          String     @id @default(cuid())
  userId      String
  bookId      String
  name        String
  toolRunIds  String[]   // Ordered list of tool run IDs
  status      String     @default("active")  // 'active' | 'completed' | 'archived'
  
  startedAt   DateTime   @default(now())
  completedAt DateTime?
  
  toolRuns    ToolRun[]
  
  @@index([userId])
  @@index([bookId])
  @@map("workflows")
}


// ============================================
// MY VOICE - Voice Profile Training System
// ============================================

// Voice Profile - stores trained voice models
model VoiceProfile {
  id              String   @id @default(cuid())
  userId          String
  name            String
  description     String?
  
  // Training data
  totalWordCount  Int
  sampleCount     Int
  trainingSamples TrainingSample[]
  
  // Analysis results (stored as JSON)
  analysis        Json
  
  // Generated prompts
  systemPrompt    String   @db.Text
  styleGuide      String   @db.Text
  
  // Usage tracking
  timesUsed       Int      @default(0)
  lastUsedAt      DateTime?
  
  // Status
  status          String   @default("ready") // training, ready, error
  trainingProgress Int?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userId])
  @@map("voice_profiles")
}

// Training Samples - individual writing samples used for training
model TrainingSample {
  id              String   @id @default(cuid())
  voiceProfileId  String
  voiceProfile    VoiceProfile @relation(fields: [voiceProfileId], references: [id], onDelete: Cascade)
  
  source          String   // paste, upload, chapter
  sourceId        String?  // chapterId if from a chapter
  sourceName      String
  text            String   @db.Text
  wordCount       Int
  
  addedAt         DateTime @default(now())
  
  @@index([voiceProfileId])
  @@map("training_samples")
}

// Voice Usage Log - tracks when voices are used in generation
model VoiceUsageLog {
  id              String   @id @default(cuid())
  voiceProfileId  String
  userId          String
  
  toolId          String
  chapterId       String?
  bookId          String?
  
  inputWordCount  Int
  outputWordCount Int
  satisfaction    Int?     // 1-5 rating if user provides feedback
  
  createdAt       DateTime @default(now())
  
  @@index([voiceProfileId])
  @@index([userId])
  @@map("voice_usage_logs")
}


// ============================================
// CONTINUITY GUARDIAN - Fact & Consistency Tracking
// ============================================

// Story Facts - trackable facts extracted from chapters
model StoryFact {
  id              String   @id @default(cuid())
  bookId          String
  
  // Fact details
  category        String   // character_trait, timeline, location, etc.
  subject         String   // Who/what the fact is about
  attribute       String   // What aspect
  value           String   // Original value
  currentValue    String   // Current value (may have changed)
  
  // Where established
  establishedIn   Json     // { chapterId, chapterTitle, excerpt, position }
  
  // Change history
  history         Json[]   @default([])
  
  // Metadata
  confidence      String   @default("explicit") // explicit, implied, inferred
  importance      String   @default("significant") // critical, significant, minor
  source          String   @default("extracted") // extracted, user, story_bible
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([bookId])
  @@index([category])
  @@index([subject])
  @@map("story_facts")
}

// Book Timeline Events - story-level timeline (different from series TimelineEvent)
model BookTimelineEvent {
  id              String   @id @default(cuid())
  bookId          String
  
  // Event details
  description     String
  storyTime       Json     // { type, value, dayNumber? }
  
  // Location in manuscript
  chapterId       String
  chapterTitle    String
  sceneId         String?
  position        Int      @default(0)
  
  // Participants
  characters      String[] @default([])
  locations       String[] @default([])
  
  // Metadata
  importance      String   @default("significant")
  
  createdAt       DateTime @default(now())
  
  @@index([bookId])
  @@index([chapterId])
  @@map("book_timeline_events")
}

// Consistency Issues - detected problems
model ConsistencyIssue {
  id              String   @id @default(cuid())
  bookId          String
  
  // Issue details
  type            String   // contradiction, timeline_conflict, etc.
  severity        String   @default("warning") // critical, warning, suggestion
  title           String
  description     String   @db.Text
  
  // Locations
  locations       Json[]   // [{ chapterId, chapterTitle, excerpt, position }]
  
  // Conflicting facts
  conflictingFacts Json[]  @default([])
  
  // AI suggestions
  suggestions     Json[]   @default([])
  
  // Status
  status          String   @default("open") // open, acknowledged, resolved, dismissed
  resolution      Json?    // { method, notes, resolvedAt }
  
  // Metadata
  detectedAt      DateTime @default(now())
  detectedBy      String   @default("auto") // auto, user
  
  @@index([bookId])
  @@index([status])
  @@index([severity])
  @@map("consistency_issues")
}

// Scan Status - track ongoing scans
model ScanStatus {
  bookId          String   @id
  phase           String   @default("Not started")
  progress        Int      @default(0)
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  
  @@map("scan_status")
}

// Plot Threads - track ongoing storylines
model PlotThread {
  id              String   @id @default(cuid())
  bookId          String
  
  // Thread details
  name            String
  description     String?
  status          String   @default("active") // active, resolved, abandoned
  
  // Where introduced
  introducedIn    String   // chapterId
  
  // Where last mentioned
  lastMentionedIn String?
  
  // Related elements
  characters      String[] @default([])
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([bookId])
  @@index([status])
  @@map("plot_threads")
}
